\section{System Design}
\sysname is a framework to trace advertisements that are delivered through push notification service to the end users. In this section we explain the design of \sysname and it's various componenets.

\subsection{Overview}
Multiple steps are required for a website to get an end user to subscribe to its notification service and display an ad through push notifications. It has to be noted that some of these steps mandate user interaction and requires user permission and poses as a major challenge to automate the entire process. As of now, no framework exists that allow the automation of successfully interacting with a push notification process. Therefore, we extend the chromium module of a forensic engine, JSgraph\ref{jsgraph} to suit our needs. \sysname record essential information involved at each step and automates actions that are required to successfully proceed from one step to the next. In order to record necessary information, we need a complete trace of events that happen in a chromium browser from visiting a chosen website to receiving a notification from the website and interacting with the notification. We achieve that by leveraging the modified chromium module used in JSgraph\ref{jsgraph}. As major part of our system involves chromium browser and it could be deployed in both desktop and mobile environment, We develop additional modules that would help us launch and automate interactions with chromium browser for both desktop and mobile environment. Various steps involved in the notification service of a chromium browser are shown in \ref{notification_system} and the role of \sysname at each step is explained in detail for desktop and mobile environment in the following sections.


\subsection{Desktop Environment}

\subsubsection{Handling Permission Request}
A website requires the user's permission to send push notifications. When the user visits a website, the website conveys it's intent to send a push notification to the browser. Then, the browser displays a browser dialog box to request permission from the user. To automate this process, \sysname logs the request made by the website to the browser at \texttt{RequestPermission} method of \texttt{PermissionContextBase} module in Chromium. %To mimic user's behaviour of granting permission to notifications,
We modified the \texttt{PermissionDecided} method of \texttt{PermissionContextBase} module to grant permission by default and also record the permission's status. Thus, notification permission requests from any website that \sysname visits will be granted permission automatically.


\subsubsection{Handling Service Workers}
A service worker~\cite{chrome_service_worker} plays a vital role to register, deliver, and display notification. Fig.~\ref{notification_system} illustrates the overview of the push notification service in Chromium. Service workers perform important processes including registration of the push notification (step 2), handling notification requests (step 3), sending push messages (step 5), and displaying the notification (step 6). Furthermore, service worker also play a role to open a website (i.e., landing page) if the user clicks the notification (step 7). We explain in details how service workers serve push notifications and the information we record at each step.

\textbf{\indent{Registration (step 2): }}
Any website can register a service worker script without user authentication it satisfies certain criteria~\cite{chrome_serviceworker}. We instrument \texttt{ServiceWorkerContainer} module in Chromium to hook \texttt{register} event that allows us to log registration of each service worker. The information we log is including the URL of the service worker and the website origin that registered the service worker. Once the service worker registered, it can subscribe for push messaging service of the browser. During this subscription, an application server key is passed to the browser to identify the app server via Google Firebase Cloud Messaging (FCM)~\cite{google_fcm}. This key denotes the party responsible for sending push messages. Hence, we record the key information at \texttt{subscribe} method of \texttt{pushmanager} module in Chromium.  At this point, the status of service worker is active and ready.

\textbf{\indent{Requests (step 3): }}
After a service worker is activated, it can send push notification requests to any server, including web-server that the user visited or a third-party advertising network.
%The third-party servers could vary from any ad network servers that are responsible for serving ads to a server that tracks certain measurements at regular interval. 
These requests made by service workers are outside the context of the webpage, and thus, we need to record them at the service worker context. We instrument the service worker module to hook \texttt{request} event. It allows us to log all push notification request events from each service worker when they are registered using \texttt{Puppeteer} tool. \KYU{What is puppeteer tool? Please explain it.} Also, we hook \texttt{response} event in a similar fashion. The information collected related to the requests and responses are \texttt{request-origin},  \texttt{request-url}, \texttt{post-data}, \texttt{redirections} and \texttt{response-content}. The response content is recorded in the log file for further analysis.


\textbf{\indent{Handling Push Messages and Notification (steps 5\&6): }}
The browser receives push message from the cloud messaging service and alerts the service worker that is responsible to receive the content. Each service worker has a unique identifier which is specified in the push message. Then, the service worker receives the push message by listening to \texttt{push} event and invokes the \texttt{showNotification} method of \texttt{ServiceWorkerRegistrationNotifications} module in chromium by passing the necessary data. However, it is not mandatory for a service worker to invoke \texttt{showNotification} method. In such case, the chrome browser would still by default display a notification by invoking the same method. Hence, we record the data at \texttt{showNotification} method by invoking the \texttt{WillShowNotification} method of \texttt{Forensics} module. The data collected includes \texttt{service worker URL}, \texttt{notification title}, \texttt{notification body}, \texttt{notification image URL} and \texttt{notification target URL}. Further, whenever a request is made by the service worker as mentioned in step 3, a screenshot of the entire desktop is captured. AS, a service worker is bound to make a request for an image to display for notification, capturing a screenshot after a short delay of each request helps us capture the notification that is displayed by the browser.


\textbf{\indent{Handling User Interaction with Notification (steps 7\&8): }}
When a user clicks a displayed notification, the service worker could listen to click event and it could either do nothing or navigate the user to a web page. We wanted to record this observation for further analysis. However, the challenges at this stage include emulating an user click once a notification is displayed and recording the events that occur once the click happens. First, to emulate an user's click, since the notification itself is on a different context than the web page, the automation tool \texttt{Puppeteer} cannot be used to emulate a click. However, in the chromium environment, the method \texttt{Add} of \texttt{MessageCenterNotificationManager} module is responsible for generating the notification. Also, the \texttt{Click} method of \texttt{WebNotificationDelegate} triggers a click on the notification. Therefore, we modified the \texttt{MessageCenterNotificationManager.Add} method to invoke \texttt{WebNotificationDelegate.Click} after a delay of 10 seconds. The delay is meant to provide enough time to capture a screenshot of the notification. Second, if the click results in a navigation to a web page, the modified chromium as mentioned in JSgraph \ref{jsgraph} records all redirection and fine-grained details of the page and its execution. At this stage, a service worker may listen to click and close events of notification shown and contact a server to report this information.

\input{android_system.tex}
